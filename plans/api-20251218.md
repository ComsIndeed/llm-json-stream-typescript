# API Change Plans for llm-json-stream
> Written on 2025-12-18 | Updated on 2025-12-20

This document outlines the planned API changes for the `llm-json-stream` package based on the changelog entries up to version 0.1.0.

## The Target API

### 1. Setup
```typescript
interface User {
    name: string;
    age: number;
    email: string;
}

interface UsersResponse {
    label: string;
    description: string;
    users: User[];
}

// The LLM is told to write a JSON of users list
const response = await llm.sendPrompt(prompt);
```

### 2. Creating an instance
```typescript
const usersStream: JsonStream<UsersResponse> = JsonStream.parse<UsersResponse>(response);
```
- This allows for a schema to be enforced
- This empowers TypeScript users with autocomplete
- This lets Javascript users to not define types

### 3. Property Access

#### Manual Access (using `.get<T>(path)`)
```typescript
// Direct get for a single value (promise & iterable)
const label: AsyncJson<string> = usersStream.get<string>('label');
const labelValue: string = await label;

// Streaming chunks for a string property
for await (const chunk of usersStream.get<string>('description')) {
    console.log(chunk);
}

// Streaming array items (each element is an AsyncJson<T>)
for await (const user of usersStream.get<User[]>('users')) {
    const name: string = await user.get<string>('name');
    for await (const nameChunk of user.get<string>('name')) {
        console.log(nameChunk);
    }
}
```

#### Path-based Access (using `.paths()`)
```typescript
// Using the paths() helper for a more ergonomic style
const users: AsyncJsonPath<UsersResponse> = usersStream.paths();

// Promise-style access
const name: string = await users.name;

// Streaming chunks
for await (const chunk of users.description) {
    console.log(chunk);
}

// Nested access
const firstUser: AsyncJsonPath<User> = users.users[0];
const firstName: string = await firstUser.name;

// Chained access
const firstUserEmail: string = await users.users[0].email;
```

### 4. Type Safety
```typescript
// Using .get<T>() - explicit type parameter
const name: AsyncJson<string> = usersStream.get<string>('users[0].name');
const age: AsyncJson<number> = usersStream.get<number>('users[0].age');

// Using .paths() - types inferred from schema
const userPaths = usersStream.paths();
const name2: string = await userPaths.users[0].name; // inferred as string
const age2: number = await userPaths.users[0].age;   // inferred as number
```

### 5. Support for no-schema usage
```typescript
// Without schema - no type checking
const dynamicStream = JsonStream.parse(response);
const value = await dynamicStream.get('someProperty');

// Can still use paths() but without type safety
const paths = dynamicStream.paths();
const data = await paths.someProperty;
```

## Side-By-Side Preview of the API Change

Let's say this is for a blog response:

### Current API
```typescript
const parser = new JsonStreamParser(response);

const label = await parser.getStringProperty('label').promise;

for await (const chunk of parser.getStringProperty('description')) {
    console.log(chunk);
}
```

### New API (Manual Access)
```typescript
const blog: JsonStream<BlogResponse> = JsonStream.parse<BlogResponse>(response);

const label: string = await blog.get<string>('label');

for await (const chunk of blog.get<string>('description')) {
    console.log(chunk);
}
```

### New API (Path-based Access)
```typescript
const blog: JsonStream<BlogResponse> = JsonStream.parse<BlogResponse>(response);
const blogPaths: AsyncJsonPath<BlogResponse> = blog.paths();

const label: string = await blogPaths.label;

for await (const chunk of blogPaths.description) {
    console.log(chunk);
}
```

## Core Type Definitions

```typescript
// The main parser object returned by JsonStream.parse<T>()
interface JsonStream<T> {
    get<U>(path: string): AsyncJson<U>;
    paths(): AsyncJsonPath<T>;
    // ... other utility methods
}

// The async/streamable value returned by .get<T>()
interface AsyncJson<T> extends Promise<T>, AsyncIterable<T> {
    get<U>(path: string): AsyncJson<U>;
    // ... other methods
}

// The proxy object returned by .paths() for ergonomic property access
type AsyncJsonPath<T> = {
    [K in keyof T]: T[K] extends object 
        ? AsyncJsonPath<T[K]> & AsyncJson<T[K]>
        : AsyncJson<T[K]>;
};
```

## Steps to Transition to the New API

### A. Create new schema-full tests
- Create a new set of tests that use the new `JsonStream.parse<T>(stream)` API with schema interfaces
    - Cover all property types: string, number, boolean, null, list, map
    - Cover nested properties and arrays
    - Cover streaming chunks and final values
    - Cover error handling and edge cases

### B. Migrate to late-binding parsing
- Update all the tests to use `JsonStream.parse<T>(stream)` instead of `new JsonStreamParser(stream)`, where T is an optional schema interface
    - So when Copilot rewrites the code, it can keep running the tests to make sure it still works
- Implement late-binding parsing to support the new `JsonStream.parse<T>(stream)` function
    - We only infer the stream type when the property starts generating, meaning we will probably have a new type of PropertyStream that will temporarily be generic until it starts generating, then it will convert itself to the actual type-specific PropertyStream (StringProperty, NumberProperty, etc)

### C. Flatten PropertyStream
- Update all tests to use the flattened API without `.promise` property
    - So when Copilot rewrites the code, it can keep running the tests to make sure it still works
- Refactor `PropertyStream` and its subclasses (`StringProperty`, `NumberProperty`, etc) to be *thenable* and iterable (already done), removing the need for `.promise` property

### D. Implement `.get<T>(path)` accessor
- Update all tests to use `.get<T>(path)` instead of type-specific methods
    - Replace `getStringProperty('path')` with `get<string>('path')`
    - Replace `getNumberProperty('path')` with `get<number>('path')`
    - Etc.
- Implement the unified `.get<T>(path)` method that returns `AsyncJson<T>`

### E. Implement `.paths()` proxy accessor
- Add tests for the new `.paths()` API
- Implement proxy-based property access using JavaScript Proxies
- Handle critical proxy traps to ensure compatibility:
    - **`then` trap**: Return the actual `then` function to maintain Promise compatibility
    - **`toJSON` trap**: Return current snapshot or undefined to prevent stack overflow in `JSON.stringify`
    - **Symbol traps**: Return undefined for framework symbols (`__esModule`, `$$typeof`, `_isVue`, etc.)
    - **`util.inspect.custom` trap**: Implement pretty printing for Node.js console logging
    - **Truthiness handling**: Document that checking existence without `await` is not supported
- The `.paths()` method returns an `AsyncJsonPath<T>` that wraps each property access in an `AsyncJson<T>`

## Questions to Answer

1. **What is the new name for `JsonStreamParser`?**  
   Answer: `JsonStream.parse<T>(stream)` function, which returns a `JsonStream<T>` object.

2. **What is the new name for `PropertyStream` and its subclasses?**  
   Answer: `AsyncJson<T>` - a unified type that is both a Promise and an AsyncIterable.

3. **What new accessor methods are introduced?**  
   Answer: 
   - `.get<T>(stringPath)` - returns `AsyncJson<T>` (both promise & iterable)
   - `.paths()` - returns `AsyncJsonPath<T>`, a proxy object for ergonomic property access

4. **What's the difference between `.get<T>(path)` and `.paths()`?**  
   Answer:
   - `.get<T>(path)` - Manual string-based path access, returns `AsyncJson<T>` directly
   - `.paths()` - Returns a typed proxy object that allows dot-notation and bracket-notation access with full TypeScript autocomplete

## Snapshots of Old Code for Reference

### Current Lists of Tests and Coverage

- **Property Type Tests** (in `properties/` folder)
    - `string_property.test.ts`
        - Tests for string property parsing with streaming interface
        - Covers: simple strings, escape sequences (newline, tab, quotes, backslash), empty strings, unicode/emoji characters, long strings chunked across multiple stream chunks, nested properties, async iterator patterns
        - Total: 11 test cases
    - `number_property.test.ts`
        - Tests for numeric property parsing (atomic values - emit once)
        - Covers: positive/negative integers, zero, negative zero, floating point, scientific notation, nested numbers, numbers in arrays, multiple number properties
        - Total: 15+ test cases
    - `boolean_property.test.ts`
        - Tests for boolean property parsing (atomic values - emit once)
        - Covers: true/false values, nested booleans, booleans in arrays, multiple boolean properties, async iterator patterns
        - Total: 9+ test cases
    - `null_property.test.ts`
        - Tests for null property parsing (atomic values - emit once)
        - Covers: null values, nested nulls, nulls in arrays, multiple null properties, async iterator emit behavior
        - Total: 9+ test cases
    - `list_property.test.ts`
        - Tests for array/list property parsing with snapshot emissions
        - Covers: simple arrays, empty arrays, arrays of strings/objects/mixed types, nested arrays, element access by index, onElement callbacks, streaming snapshots
        - Total: 15+ test cases
    - `map_property.test.ts`
        - Tests for object/map property parsing with snapshot emissions
        - Covers: simple objects, empty objects, nested objects, mixed value types, deeply nested objects, dot notation access, chainable property access, async iterator snapshots
        - Total: 12+ test cases

- **Integration & Robustness Tests** (in root `test/` folder)
    - `comprehensive_demo.test.ts`
        - Matrix testing of chunk sizes and stream speeds
        - Covers: variations with chunkSize [1, 3, 10, 50, 100, 1000] and speeds [0, 5, 50, 100]ms
    - `stream_completion.test.ts`
        - Tests for stream completion and promise resolution
        - Covers: all properties completing when stream ends, futures resolution, incomplete property handling
    - `error_handling.test.ts`
        - Tests for error handling and edge cases
        - Covers: complete JSON parsing, slow stream timeouts, empty objects, whitespace handling
    - `incremental_updates.test.ts`
        - Tests for incremental property updates during streaming
    - `buffer_flush.test.ts`
        - Tests for buffer flushing behavior
    - `disposal.test.ts`
        - Tests for proper resource cleanup and disposal
    - `multiline_json.test.ts`
        - Tests for multiline JSON parsing
    - `trailing_commas.test.ts`
        - Tests for trailing comma handling
    - `llm_robustness.test.ts`
        - Tests for LLM-generated JSON robustness
    - `comprehensive_value_retrieval.test.ts`
        - Tests for comprehensive value retrieval scenarios
    - `map_on_property.test.ts`
        - Tests for map operations on properties
    - `debug_simple.test.ts`, `debug_nested_list.test.ts`, `bug_diagnosis.test.ts`, `critical_bug.test.ts`, `yap_filter.test.ts`
        - Focused debugging and bug reproduction tests

## Critical Proxy Implementation Notes

When implementing `.paths()`, ensure these traps are handled:

1. **`then` Guard** - Return actual `then` function to maintain Promise compatibility
2. **`toJSON` Trap** - Prevent infinite recursion in `JSON.stringify`
3. **Truthiness Trap** - Document that existence checks require `await`
4. **`util.inspect.custom`** - Pretty-print for Node.js console
5. **Symbol/Framework Flags** - Return `undefined` for `__esModule`, `$$typeof`, `_isVue`, etc.

These ensure the proxy works seamlessly with promises, JSON serialization, logging, and popular frameworks.