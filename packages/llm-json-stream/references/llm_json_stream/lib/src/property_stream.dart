import 'dart:async';

import 'json_stream_parser.dart';
import 'parse_event.dart';
import 'property_stream_controller.dart';
import 'property_getter_mixin.dart';

/// Base class for all property streams.
///
/// Property streams provide access to JSON values as they are parsed from
/// the input stream. Each property stream has a [future] that completes
/// with the final parsed value.
///
/// ## Subclasses
///
/// - [StringPropertyStream] - For JSON string values
/// - [NumberPropertyStream] - For JSON number values
/// - [BooleanPropertyStream] - For JSON boolean values
/// - [NullPropertyStream] - For JSON null values
/// - [MapPropertyStream] - For JSON object values
/// - [ListPropertyStream] - For JSON array values
///
/// ## Common API
///
/// All property streams provide:
/// - [future] - Completes with the final parsed value
/// - [onLog] - Register callbacks for parsing events
abstract class PropertyStream<T> {
  final Future<T> _future;

  /// A future that completes with the final parsed value of this property.
  ///
  /// Use this when you need the complete value and don't need to react to
  /// partial chunks.
  Future<T> get future => _future;
  final JsonStreamParserController _parserController;

  /// The property path for this stream, used for logging.
  String get _propertyPath;

  MapPropertyStream get asMap => this as MapPropertyStream;
  ListPropertyStream get asList => this as ListPropertyStream;
  StringPropertyStream get asStr => this as StringPropertyStream;
  NumberPropertyStream get asNum => this as NumberPropertyStream;
  BooleanPropertyStream get asBool => this as BooleanPropertyStream;
  NullPropertyStream get asNull => this as NullPropertyStream;

  PropertyStream({
    required Future<T> future,
    required JsonStreamParserController parserController,
  })  : _future = future,
        _parserController = parserController;

  /// Registers a callback to receive log events for this property and its descendants.
  ///
  /// The callback will receive [ParseEvent] objects for parsing events that
  /// occur at this property path or any nested paths.
  ///
  /// Example:
  /// ```dart
  /// parser.getMapProperty('user').onLog((event) {
  ///   print('User parsing: ${event.type} - ${event.message}');
  /// });
  /// ```
  void onLog(void Function(ParseEvent event) callback) {
    try {
      final controller =
          _parserController.getPropertyStreamController(_propertyPath);
      controller.addOnLogCallback(callback);
    } catch (_) {
      // Controller doesn't exist yet - this is fine
    }
  }
}

/// A property stream for JSON string values.
///
/// Provides both a [stream] that emits string chunks as they are parsed,
/// and a [future] that completes with the complete string value.
///
/// ## Streaming Behavior
///
/// String values are unique in that they emit **chunks** as the JSON streams in,
/// rather than waiting for the complete value. This enables real-time text display
/// for LLM responses.
///
/// ## Example
///
/// ```dart
/// final titleStream = parser.getStringProperty('title');
///
/// // React to chunks as they arrive
/// titleStream.stream.listen((chunk) {
///   displayText += chunk; // Update UI incrementally
/// });
///
/// // Or wait for the complete value
/// final fullTitle = await titleStream.future;
/// ```
class StringPropertyStream extends PropertyStream<String> {
  @override
  final String _propertyPath;

  StringPropertyStream({
    required super.future,
    required Stream<String> liveStream,
    required Stream<String> Function() replayableStreamFactory,
    required super.parserController,
    required String propertyPath,
  })  : _propertyPath = propertyPath,
        _liveStream = liveStream,
        _replayableStreamFactory = replayableStreamFactory;

  final Stream<String> _liveStream;
  final Stream<String> Function() _replayableStreamFactory;

  /// A stream that emits string chunks as they are parsed.
  ///
  /// Each chunk represents a portion of the string value as it arrives
  /// from the input stream. This is useful for displaying text as it's
  /// being generated by an LLM.
  ///
  /// Note: This stream does not replay past chunks to new subscribers.
  Stream<String> get unbufferedStream => _liveStream;

  /// A stream that emits string chunks as they are parsed.
  ///
  /// Each chunk represents a portion of the string value as it arrives
  /// from the input stream. This is useful for displaying text as it's
  /// being generated by an LLM.
  ///
  /// Note: This stream will emit all past chunks to new subscribers.
  Stream<String> get stream => _replayableStreamFactory();
}

/// A property stream for JSON number values.
///
/// Provides a [future] that completes with the parsed number value.
/// Numbers are atomic values, so the stream emits once when complete.
///
/// ## Example
///
/// ```dart
/// final age = await parser.getNumberProperty('user.age').future;
/// print('Age: $age');
/// ```
class NumberPropertyStream extends PropertyStream<num> {
  @override
  final String _propertyPath;

  NumberPropertyStream({
    required super.future,
    required Stream<num> stream,
    required super.parserController,
    required String propertyPath,
  })  : _propertyPath = propertyPath,
        _stream = stream;

  final Stream<num> _stream;

  /// A stream that emits the number value when parsing is complete.
  Stream<num> get stream => _stream;
}

/// A property stream for JSON null values.
///
/// Provides a [future] that completes with null when the null value
/// is fully parsed.
class NullPropertyStream extends PropertyStream<Null> {
  @override
  final String _propertyPath;

  NullPropertyStream({
    required super.future,
    required Stream<Null> stream,
    required super.parserController,
    required String propertyPath,
  })  : _propertyPath = propertyPath,
        _stream = stream;

  final Stream<Null> _stream;

  /// A stream that emits null when parsing is complete.
  Stream<Null> get stream => _stream;
}

/// A property stream for JSON boolean values.
///
/// Provides a [future] that completes with the parsed boolean value.
class BooleanPropertyStream extends PropertyStream<bool> {
  @override
  final String _propertyPath;

  BooleanPropertyStream({
    required super.future,
    required Stream<bool> stream,
    required super.parserController,
    required String propertyPath,
  })  : _propertyPath = propertyPath,
        _stream = stream;

  final Stream<bool> _stream;

  /// A stream that emits the boolean value when parsing is complete.
  Stream<bool> get stream => _stream;
}

/// A property stream for JSON array values.
///
/// Provides:
/// - A [future] that completes with the full parsed list
/// - A [stream] that replays buffered values and then emits new values (recommended)
/// - An [unbufferedStream] that only emits new values without replay
/// - An [onElement] callback for reacting to elements as they start parsing
/// - Chainable property getters to access list elements
///
/// ## onElement Callback
///
/// The [onElement] callback enables "arm the trap" behavior, firing immediately
/// when a new array element is discovered (before it's fully parsed):
///
/// ```dart
/// final items = parser.getListProperty('items');
/// items.onElement((element, index) {
///   print('Element $index started');
///   // Set up subscriptions for this element
/// });
/// ```
///
/// ## Accessing Elements
///
/// Access specific elements using bracket notation:
/// ```dart
/// final firstItem = parser.getMapProperty('items[0]');
/// final secondName = parser.getStringProperty('items[1].name');
/// ```
class ListPropertyStream<T extends Object?> extends PropertyStream<List<T>>
    with PropertyGetterMixin {
  @override
  final String _propertyPath;
  final Stream<List<T>> _liveStream;
  final Stream<List<T>> Function() _replayableStreamFactory;

  /// A stream that emits list snapshots as they are parsed.
  ///
  /// Each emission represents the current state of the list as parsing progresses.
  /// This is useful for building reactive UIs that update as data arrives.
  ///
  /// Note: This stream does not replay past emissions to new subscribers.
  Stream<List<T>> get unbufferedStream => _liveStream;

  /// A stream that emits list snapshots as they are parsed.
  ///
  /// Each emission represents the current state of the list as parsing progresses.
  /// This is useful for building reactive UIs that update as data arrives.
  ///
  /// Note: This stream will emit all past snapshots to new subscribers,
  /// preventing race condition issues when subscribing late.
  Stream<List<T>> get stream => _replayableStreamFactory();

  ListPropertyStream({
    required Stream<List<T>> liveStream,
    required Stream<List<T>> Function() replayableStreamFactory,
    required super.future,
    required super.parserController,
    required String propertyPath,
  })  : _propertyPath = propertyPath,
        _liveStream = liveStream,
        _replayableStreamFactory = replayableStreamFactory;

  /// Registers a callback that fires when each array element starts parsing.
  ///
  /// The [callback] receives:
  /// - `propertyStream`: A property stream for the new element (type depends on element)
  /// - `index`: The zero-based index of the element in the array
  ///
  /// This fires immediately when the parser encounters the start of a new
  /// element, before the element is fully parsed. This enables building
  /// reactive UIs that can add placeholder elements and fill them in as
  /// data arrives.
  ///
  /// Example:
  /// ```dart
  /// items.onElement((element, index) {
  ///   if (element is MapPropertyStream) {
  ///     element.getStringProperty('name').stream.listen((name) {
  ///       print('Item $index name: $name');
  ///     });
  ///   }
  /// });
  /// ```
  void onElement(
    void Function(PropertyStream propertyStream, int index) callback,
  ) {
    // Add callback to the controller's list, not our local copy
    final controller =
        parserController.getPropertyStreamController(_propertyPath)
            as ListPropertyStreamController<T>;
    controller.addOnElementCallback(callback);
  }

  @override
  String buildPropertyPath(String key) {
    // For array indices like "[0]", don't add a dot separator
    return _propertyPath.isEmpty
        ? key
        : (key.startsWith('[') ? '$_propertyPath$key' : '$_propertyPath.$key');
  }

  @override
  JsonStreamParserController get parserController => _parserController;
}

/// A property stream for JSON object (map) values.
///
/// Provides:
/// - A [future] that completes with the full parsed map
/// - A [stream] that replays buffered values and then emits new values (recommended)
/// - An [unbufferedStream] that only emits new values without replay
/// - An [onProperty] callback for reacting to properties as they start parsing
/// - Chainable property getters to access nested properties
///
/// ## onProperty Callback
///
/// The [onProperty] callback enables "arm the trap" behavior, firing immediately
/// when a new object property is discovered (before it's fully parsed):
///
/// ```dart
/// final user = parser.getMapProperty('user');
/// user.onProperty((property, key) {
///   print('Property "$key" started');
///   // Set up subscriptions for this property
/// });
/// ```
///
/// ## Chainable Access
///
/// Access nested properties using the chainable API:
/// ```dart
/// parser.getMapProperty('user')
///       .getStringProperty('name')
///       .stream.listen(print);
/// ```
class MapPropertyStream extends PropertyStream<Map<String, Object?>>
    with PropertyGetterMixin {
  @override
  final String _propertyPath;
  final Stream<Map<String, dynamic>> _liveStream;
  final Stream<Map<String, dynamic>> Function() _replayableStreamFactory;

  /// A stream that emits map snapshots as they are parsed.
  ///
  /// Each emission represents the current state of the map as parsing progresses.
  /// This is useful for building reactive UIs that update as data arrives.
  ///
  /// Note: This stream does not replay past emissions to new subscribers.
  Stream<Map<String, dynamic>> get unbufferedStream => _liveStream;

  /// A stream that emits map snapshots as they are parsed.
  ///
  /// Each emission represents the current state of the map as parsing progresses.
  /// This is useful for building reactive UIs that update as data arrives.
  ///
  /// Note: This stream will emit all past snapshots to new subscribers,
  /// preventing race condition issues when subscribing late.
  Stream<Map<String, dynamic>> get stream => _replayableStreamFactory();

  MapPropertyStream({
    required super.future,
    required super.parserController,
    required String propertyPath,
    required Stream<Map<String, dynamic>> liveStream,
    required Stream<Map<String, dynamic>> Function() replayableStreamFactory,
  })  : _propertyPath = propertyPath,
        _liveStream = liveStream,
        _replayableStreamFactory = replayableStreamFactory;

  /// Registers a callback that fires when each object property starts parsing.
  ///
  /// The [callback] receives:
  /// - `propertyStream`: A property stream for the new property (type depends on value)
  /// - `key`: The string key of the property in the object
  ///
  /// This fires immediately when the parser encounters the start of a new
  /// property value, before the value is fully parsed. This enables building
  /// reactive UIs that can add placeholder elements and fill them in as
  /// data arrives.
  ///
  /// Example:
  /// ```dart
  /// user.onProperty((property, key) {
  ///   if (property is StringPropertyStream) {
  ///     property.stream.listen((chunk) {
  ///       print('Property "$key" chunk: $chunk');
  ///     });
  ///   }
  /// });
  /// ```
  void onProperty(
    void Function(PropertyStream propertyStream, String key) callback,
  ) {
    // Add callback to the controller's list
    final controller =
        parserController.getPropertyStreamController(_propertyPath)
            as MapPropertyStreamController;
    controller.addOnPropertyCallback(callback);
  }

  @override
  String buildPropertyPath(String key) {
    return _propertyPath.isEmpty ? key : '$_propertyPath.$key';
  }

  @override
  JsonStreamParserController get parserController => _parserController;
}
